/*
 * $QNXLicenseC:
 * Copyright 2014, QNX Software Systems.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You
 * may not reproduce, modify or distribute this software except in
 * compliance with the License. You may obtain a copy of the License
 * at: http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OF ANY KIND, either express or implied.
 *
 * This file may contain contributions from others, either as
 * contributors under the License or as licensors under other terms.
 * Please review this entire file for other proprietary rights or license
 * notices, as well as the QNX Development Suite License Guide at
 * http://licensing.qnx.com/license-guide/ for other information.
 * $
 */

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <malloc.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>
#include <hw/inout.h>
#include <sys/syspage.h>
#include <inttypes.h>
#include <hw/sysinfo.h>
#include <drvr/hwinfo.h>

#include "canmx6x.h"
#include "proto.h"
#include "externs.h"

// Default IRQ's for RINGO board
#define RINGO_CAN0_SYSINTR        43
#define RINGO_CAN1_SYSINTR        44

typedef enum {CAN_BR_50K, CAN_BR_125K, CAN_BR_250K, CAN_BR_500K, CAN_BR_1M} bitrate_sel_t;

/*  50K, 125K, and 250K based on old values that were in the driver. 500K and
 *  1M were generated by the calculator here:
 *  http://www.bittiming.can-wiki.info/
 *  On that calculator sjw=rjw
 *
 *  All of these timings are based on a 60 MHz input clock.
 */
const struct {
    unsigned int presdiv;
    unsigned int propseg;
    unsigned int pseg1;
    unsigned int pseg2;
    unsigned int rjw;
} predefined_bitrates[5] = {
    /*                presdiv, propseg,   pseg1,   pseg2,  rjw */
    [CAN_BR_50K]  = {    0x55,    0x02,    0x07,    0x01,    0},
    [CAN_BR_125K] = {    0x21,    0x02,    0x07,    0x01,    0},
    [CAN_BR_250K] = {    0x10,    0x02,    0x07,    0x01,    0},
    [CAN_BR_500K] = {    0x07,    0x03,    0x07,    0x01,    1},
    [CAN_BR_1M]   = {    0x03,    0x03,    0x07,    0x01,    1},
};

//#define DEBUG_DRVR

// Function prototypes
void device_init(int argc, char *argv[]);
void create_device(CANDEV_RINGO_INIT *devinit);

typedef struct candev_hwinfo {
    paddr_t regbase;
    paddr_t reglen;
    paddr_t membase;
    paddr_t memlen;
    unsigned irqvector;
} CANDEV_HWINFO;


static int get_can_hwinfo(CANDEV_HWINFO *candev, unsigned unit)
{
    unsigned hwi_off;

    hwi_off = hwi_find_bus(HWI_ITEM_BUS_CAN, unit);
    if (hwi_off != HWI_NULL_OFF)
    {
        hwiattr_can_t attr;

        hwiattr_get_can(hwi_off, &attr);

        candev->regbase = attr.common.location.base;

        if (attr.common.num_irq > 0)
            candev->irqvector = hwitag_find_ivec(hwi_off, NULL);

        if (attr.num_memaddr > 0)
        {
            unsigned instance = 1;
            hwi_tag *tag = hwi_tag_find(hwi_off, HWI_TAG_NAME_location, &instance);
            candev->membase = tag->location.base;
        }

        return 0;
    }
    else
        return -1;
}


int main(int argc, char *argv[])
{
    // Driver implemented functions called by CAN library
    can_drvr_funcs_t     drvr_funcs = {can_drvr_transmit, can_drvr_devctl};

    // Get I/O privity - new flags introduced in 6.6 must be set up to access the CAN register space
    ThreadCtl( PRIVITY_FLAGS, 0 );

    // Initialize Resource Manager
    can_resmgr_init(&drvr_funcs);

    // Process options and create devices
    device_init(argc, argv);

    // Start Handling Clients
    can_resmgr_start();

    return EXIT_SUCCESS;
}

void device_init(int argc, char *argv[])
{
    int                     opt, hwi_can0, hwi_can1;
    int                     numcan = 0;
    char                   *cp;
    CANDEV_HWINFO           can0, can1;

    // Set default options
    CANDEV_RINGO_INIT     devinit =
    {
        {   CANDEV_TYPE_RX,                      /* devtype */
            0,                                   /* can_unit - set this later */
            0,                                   /* dev_unit - set this later*/
            /* msgq_size  - max number of queued CAN messages per mailbox */
            100,
            /* waitq_size - max number of clients blocked wait for
               receive messages */
            16,
        },
        RINGO_CAN0_REG_BASE,                     /* port */
        RINGO_CAN0_MEM_BASE,                     /* mem */
        RINGO_CAN_CLK_PLL,                       /* clk */
        0,                                       /* bitrate */
        predefined_bitrates[CAN_BR_50K].presdiv, /* br_presdiv */
        predefined_bitrates[CAN_BR_50K].propseg, /* br_propseg */
        predefined_bitrates[CAN_BR_50K].rjw,     /* br_rjw */
        predefined_bitrates[CAN_BR_50K].pseg1,   /* br_pseg1 */
        predefined_bitrates[CAN_BR_50K].pseg2,   /* br_pseg2 */
        RINGO_CAN0_SYSINTR,                      /* irqsys for RINGO board */
        INIT_FLAGS_MDRIVER_INIT,                 /* flags */
        /* numtx - number of transmit mailboxes */
        CAN_NUM_MAILBOX_USER/2,
        /* numrx - number of receive mailboxes */
        CAN_NUM_MAILBOX_USER/2,
        0x100C0000,                              /* midrx */
        0x100C0000,                              /* midtx */
        0x0,                                     /* timestamp */
    };

    hwi_can0 = hwi_can1 = -1;
    hwi_can0 = get_can_hwinfo(&can0, 0);
    hwi_can1 = get_can_hwinfo(&can1, 1);

    // Process command line options and create associated devices
    while(optind < argc)
    {
        // Process dash options
        while((opt = getopt(argc, argv, "ab:B:c:Di:l:m:Mn:pRsStu:vwxz"))
              != -1)
        {
            switch(opt){
            case 'a':
                devinit.flags |= INIT_FLAGS_AUTOBUS;
                break;
            case 'b': {
                    bitrate_sel_t br;

                    if(strncmp(optarg, "50K", 3) == 0) {
                        br = CAN_BR_50K;
                    } else if(strncmp(optarg, "125K", 4) == 0) {
                        br = CAN_BR_125K;
                    } else if(strncmp(optarg, "250K", 4) == 0) {
                        br = CAN_BR_250K;
                    } else if(strncmp(optarg, "500K", 4) == 0) {
                        br = CAN_BR_500K;
                    } else if(strncmp(optarg, "1M", 2) == 0) {
                        br = CAN_BR_1M;
                    } else {
                        fprintf(stderr, "Unrecognized bitrate value passed in -b option\n");
                        exit(EXIT_FAILURE);
                    }

                    devinit.br_presdiv = predefined_bitrates[br].presdiv;
                    devinit.br_propseg = predefined_bitrates[br].propseg;
                    devinit.br_pseg1   = predefined_bitrates[br].pseg1;
                    devinit.br_pseg2   = predefined_bitrates[br].pseg2;
                    devinit.br_rjw     = predefined_bitrates[br].rjw;
                }
                break;

            case 'B':
                // Values to program bitrate manually
                devinit.br_presdiv = strtoul(optarg, &optarg, 0);

                if((cp = strchr(optarg, ',')))
                {
                    cp += 1;    // Skip over the ','
                    devinit.br_propseg = strtoul(cp, &cp, 0);
                }
                if(cp && (cp = strchr(cp, ',')))
                {
                    cp += 1;    // Skip over the ','
                    devinit.br_pseg1 = strtoul(cp, &cp, 0);
                }
                if(cp && (cp = strchr(cp, ',')))
                {
                    cp += 1;    // Skip over the ','
                    devinit.br_pseg2 = strtoul(cp, &cp, 0);
                }
                if(cp && (cp = strchr(cp, ',')))
                {
                    cp += 1;    // Skip over the ','
                    devinit.br_rjw = strtoul(cp, &cp, 0);
                }

                // Check for valid bitrate settings
                if(devinit.br_rjw > RINGO_CANCTRL_RJW_MAXVAL ||
                   devinit.br_pseg1 > RINGO_CANCTRL_PSEG1_MAXVAL ||
                   devinit.br_pseg2 > RINGO_CANCTRL_PSEG2_MAXVAL ||
                   devinit.br_pseg2 == 0)
                {
                    fprintf(stderr, "Invalid manual bitrate settings\n");
                    exit(EXIT_FAILURE);
                }
                break;
            case 'D':
                devinit.flags &= ~INIT_FLAGS_MDRIVER_INIT;
                break;
            case 'i':
                devinit.midrx = strtoul(optarg, &optarg, 16);
                if((cp = strchr(optarg, ',')))
                {
                    devinit.midtx = strtoul(cp + 1, NULL, 0);
                }
                break;
            case 'm':
                devinit.flags |= INIT_FLAGS_TIMESTAMP;
                devinit.timestamp = strtoul(optarg, NULL, 16);
                break;
            case 'n':
                devinit.cinit.msgq_size = strtoul(optarg, NULL, 0);
                break;
            case 'q':
                devinit.cinit.waitq_size = strtoul(optarg, NULL, 0);
                break;
            case 'R':
                devinit.cinit.mode = CANDEV_MODE_RAW_FRAME;
                devinit.numrx = RAW_MODE_RX_NUM_MBOX;
                devinit.numtx = RAW_MODE_TX_NUM_MBOX;
                break;
            case 's':
                devinit.flags |= INIT_FLAGS_BITRATE_SAM;
                break;
            case 'S':
                devinit.flags |= INIT_FLAGS_MDRIVER_SORT;
                break;
            case 't':
                devinit.flags |= INIT_FLAGS_LOOPBACK;
                break;
            case 'u':
                devinit.cinit.can_unit = strtoul(optarg, NULL, 0);
                break;
            case 'v':
                devinit.flags |= INIT_FLAGS_LOM;
                break;
            case 'w':
                devinit.flags |= INIT_FLAGS_LBUF;
                break;
            case 'x':
                devinit.flags |= INIT_FLAGS_EXTENDED_MID;
                break;
            case 'z':
                devinit.flags |= INIT_FLAGS_TSYN;
                break;
            case 'M':
            case 'p':
            case 'c':
                fprintf(stderr, "Deprecated option -%c used.\n", optopt);
                break;

            default:
                break;
            }
        }

        // Ensure message ID is valid
        if(devinit.flags & INIT_FLAGS_EXTENDED_MID)
        {
            devinit.midrx &= RINGO_CANMID_MASK_EXT;
            devinit.midtx &= RINGO_CANMID_MASK_EXT;
        }
        else
        {
            devinit.midrx &= RINGO_CANMID_MASK_STD;
            devinit.midtx &= RINGO_CANMID_MASK_STD;
        }

        // Process ports and interrupt
        while(optind < argc && *(optarg = argv[optind]) != '-')
        {
            // Set defaults for RINGO Board CAN 1
            if(strncmp(optarg, "ringocan0", 9) == 0)
            {
                if (0 == hwi_can0) {
                    devinit.port = can0.regbase;
                    devinit.mem = can0.membase;
                    devinit.irqsys = can0.irqvector;
                } else {    // default values, They should be removed once all startups have been changed
                    devinit.port = RINGO_CAN0_REG_BASE;
                    devinit.mem = RINGO_CAN0_MEM_BASE;
                    devinit.irqsys = RINGO_CAN0_SYSINTR;
                }
                // Set default can unit number
                if(!devinit.cinit.can_unit)
                    devinit.cinit.can_unit = 0;
            }
            // Set defaults for RINGO Board CAN 2
            else if(strncmp(optarg, "ringocan1", 9) == 0)
            {
                if (0 == hwi_can1) {
                    devinit.port = can1.regbase;
                    devinit.mem = can1.membase;
                    devinit.irqsys = can1.irqvector;
                } else {    // default values, They should be removed once all startups have been changed
                    devinit.port = RINGO_CAN1_REG_BASE;
                    devinit.mem = RINGO_CAN1_MEM_BASE;
                    devinit.irqsys = RINGO_CAN1_SYSINTR;
                }
                // Set default can unit number
                if(!devinit.cinit.can_unit)
                    devinit.cinit.can_unit = 1;
            }
            // Set user defined irq's
            else
            {
                // Set default port for CAN 1
                if(strncmp(optarg, "can0", 4) == 0)
                {
                    if (0 == hwi_can0) {
                        devinit.port = can0.regbase;
                        devinit.mem = can0.membase;
                        devinit.irqsys = can0.irqvector;
                    } else {    // default values, They should be removed once all startups have been changed
                        devinit.port = RINGO_CAN0_REG_BASE;
                        devinit.mem = RINGO_CAN0_MEM_BASE;
                        // Set defaults even though user may override them
                        devinit.irqsys = RINGO_CAN0_SYSINTR;
                    }
                    // Set default can unit number
                    if(!devinit.cinit.can_unit)
                        devinit.cinit.can_unit = 0;
                    // Increment optarg
                    optarg += 4; //sizeof("can1") - 1;
                }
                // Set default port for CAN 2
                else if(strncmp(optarg, "can1", 4) == 0)
                {
                    if (0 == hwi_can1) {
                        devinit.port = can1.regbase;
                        devinit.mem = can1.membase;
                        devinit.irqsys = can1.irqvector;
                    } else {    // default values, They should be removed once all startups have been changed
                        devinit.port = RINGO_CAN1_REG_BASE;
                        devinit.mem = RINGO_CAN1_MEM_BASE;
                        // Set defaults even though user may override them
                        devinit.irqsys = RINGO_CAN1_SYSINTR;
                    }
                    // Set default can unit number
                    if(!devinit.cinit.can_unit)
                        devinit.cinit.can_unit = 1;
                    // Increment optarg
                    optarg += 4; //sizeof("can2") - 1;
                }
                else
                {
                    fprintf(stderr, "Invalid options\n");
                    exit(EXIT_FAILURE);
                }
                // Set system interrupt vector
                if(*optarg == ',') devinit.irqsys = strtoul(optarg + 1, NULL, 0);
            }
            ++optind;

            // Create the CAN device
            create_device(&devinit);
            // Reset unit number for next device
            devinit.cinit.can_unit = 0;
            numcan++;
        }
    }

    // If no devices have been created yet, create the default device
    if(numcan == 0)
    {
        // Create the default CAN device
        devinit.cinit.can_unit = 1;
        create_device(&devinit);
    }
}

void create_device(CANDEV_RINGO_INIT *devinit)
{
    CANDEV_RINGO_INFO      *devinfo;
    CANDEV_RINGO           *devlist;
    int                     mdriver_intr = -1;
    int                     i;
    unsigned int rx_dev_unit_num;
    unsigned int tx_dev_unit_num;

#ifdef DEBUG_DRVR
    fprintf(stderr, "port = 0x%X\n", devinit->port);
    fprintf(stderr, "mem = 0x%X\n", devinit->mem);
    fprintf(stderr, "clk = %d\n", devinit->clk);
    fprintf(stderr, "bitrate = %d\n", devinit->bitrate);
    fprintf(stderr, "presdiv = %d\n", devinit->br_presdiv);
    fprintf(stderr, "propseg = %d\n", devinit->br_propseg);
    fprintf(stderr, "rjw = %d\n", devinit->br_rjw);
    fprintf(stderr, "pseg1 = %d\n", devinit->br_pseg1);
    fprintf(stderr, "pseg2 = %d\n", devinit->br_pseg2);
    fprintf(stderr, "irqsys = %d\n", devinit->irqsys);
    fprintf(stderr, "unit = %u\n", devinit->cinit.can_unit);
    fprintf(stderr, "flags = %u\n", devinit->flags);
    fprintf(stderr, "numrx = %u\n", devinit->numrx);
    fprintf(stderr, "numtx = %u\n", devinit->numtx);
    fprintf(stderr, "midrx = 0x%X\n", devinit->midrx);
    fprintf(stderr, "midtx = 0x%X\n", devinit->midtx);
#endif

    // Allocate device info
    devinfo = (void *) _smalloc(sizeof(*devinfo));
    if(!devinfo)
    {
        fprintf(stderr, "devinfo: _smalloc failed\n");
        exit(EXIT_FAILURE);
    }
    memset(devinfo, 0, sizeof(*devinfo));


    // Set up CAN operation mode - single RX and TX mailboxes using raw frames
    // or multi-mailbox, I/O based communications
    devinfo->mode = devinit->cinit.mode;

    // Setup the RX and TX mailbox sizes
    devinfo->numrx = devinit->numrx;
    devinfo->numtx = devinit->numtx;
    devinfo->rxmbxstart = CAN_FIRST_USER_MAILBOX_INDEX;
    devinfo->txmbxstart = CAN_FIRST_USER_MAILBOX_INDEX + devinfo->numrx;

    // Setup the resmgr device unit numbers for rx and tx channels
    // NOTE: Errata ERR005829 has required us to reduce the number of mailboxes
    // and also adjust the mapping between mailbox number and resource manager
    // device ID's. See the 'errata' note and diagram in  mx6x-can.h.
    rx_dev_unit_num = 0;
    tx_dev_unit_num = rx_dev_unit_num + devinit->numrx;
    if (devinfo->mode == CANDEV_MODE_RAW_FRAME)
    {
        devinfo->num_mailboxes = devinit->numrx + devinit->numtx + CAN_NUM_MAILBOX_RSVD - 1;
    }
    else
    {
        devinfo->num_mailboxes = devinit->numrx + devinit->numtx + CAN_NUM_MAILBOX_RSVD;
        // Add one to skip over rx31
        tx_dev_unit_num += 1;
    }

    // Allocate an array of devices - one for each mailbox
    devlist = (void *) _smalloc(sizeof(*devlist) * devinfo->num_mailboxes);
    if(!devlist)
    {
        fprintf(stderr, "devlist: _smalloc failed\n");
        exit(EXIT_FAILURE);
    }
    memset(devlist, 0, sizeof(*devlist) * devinfo->num_mailboxes);

    // Map device registers
    devinfo->base = mmap_device_io(RINGO_CAN_REG_SIZE_FLEXCAN, devinit->port);
    if(devinfo->base == MAP_DEVICE_FAILED)
    {
        perror("CAN REG: Can't map device I/O");
        exit(EXIT_FAILURE);
    }

    // Determine if there is an active mini-driver and initialize driver to support it
    if(devinit->flags & INIT_FLAGS_MDRIVER_INIT)
    {
        mdriver_intr = mdriver_init(devinfo, devinit);
    }

    // Map device message memory
    devinfo->canmsg = mmap_device_memory(NULL, RINGO_CAN_MEM_SIZE_FLEXCAN,
                PROT_READ|PROT_WRITE|PROT_NOCACHE, 0, devinit->mem);
    if(devinfo->canmsg == MAP_FAILED)
    {
        perror("CAN MSG: Can't map device memory");
        exit(EXIT_FAILURE);
    }
    // Clear the mailbox memory if there is no mini-driver
    if(!(devinit->flags & INIT_FLAGS_MDRIVER_INIT) || mdriver_intr == -1)
        memset(devinfo->canmsg, 0, RINGO_CAN_MEM_SIZE_FLEXCAN);

    // Map CANLAM memory
    devinfo->canlam = mmap_device_io(RINGO_CANLAM_MEM_SIZE, devinit->port + RINGO_CANRXIMR0);
    if(devinfo->canlam == MAP_DEVICE_FAILED)
    {
        perror("CAN IMR: Can't map device I/O");
        exit(EXIT_FAILURE);
    }

    // Setup device info
    devinfo->devlist = devlist;
    strcpy(devinfo->initinfo.description,"MX6X FlexCAN");
    devinfo->initinfo.msgq_size = devinit->cinit.msgq_size;
    devinfo->initinfo.waitq_size = devinit->cinit.waitq_size;
    devinfo->initinfo.bitrate = devinit->bitrate;
    devinfo->initinfo.br_brp = devinit->br_presdiv;
    devinfo->initinfo.br_rjw = devinit->br_rjw;
    devinfo->initinfo.br_pseg1 = devinit->br_pseg1;
    devinfo->initinfo.br_pseg2 = devinit->br_pseg2;

    // Initialize flags
    if(devinit->flags & INIT_FLAGS_RX_FULL_MSG)
        devinfo->iflags |= INFO_FLAGS_RX_FULL_MSG;

       devinfo->iflags |= INFO_FLAGS_ENDIAN_SWAP;

    // Initialize all device mailboxes
    for(i = 0; i < devinfo->num_mailboxes; i++)
    {
        // Set index into device mailbox memory
        devlist[i].mbxid = i;
        // Store a pointer to the device info
        devlist[i].devinfo = devinfo;
        // Default the resmgr device unit number. It will get overwritten later
        // for those mailboxes which actually get exposed through the resmgr.
        devlist[i].cdev.dev_unit = -1;
        devinfo->devlist[i].cdev.devtype = -1;

        // Only expose the 'USER' mailboxes to the resource manager.
        if(i >= devinfo->rxmbxstart && i < (devinfo->txmbxstart+devinfo->numtx))
        {
            // Set device mailbox as transmit or receive and set resmgr unit number
            if(i < devinfo->txmbxstart)
            {
                devinit->cinit.devtype = CANDEV_TYPE_RX;
                devinit->cinit.dev_unit = rx_dev_unit_num++;
            }
            else
            {
                devinit->cinit.devtype = CANDEV_TYPE_TX;
                devinit->cinit.dev_unit = tx_dev_unit_num++;
            }

            // Initialize the CAN device
            can_resmgr_init_device(&devlist[i].cdev, (CANDEV_INIT *)devinit);

            // Create the resmgr device
            can_resmgr_create_device(&devlist[i].cdev);
        }
    }


    if(!(devinit->flags & INIT_FLAGS_MDRIVER_INIT) || mdriver_intr == -1)
        can_init_hw(devinfo, devinit);

#ifdef DEBUG_DRVR
    can_print_reg(devinfo);
    can_print_mailbox(devinfo);
#endif

    // Initialize interrupts and attach interrupt handler
    can_init_intr(devinfo, devinit, mdriver_intr);

}

#if defined(__QNXNTO__) && defined(__USESRCVERSION)
#include <sys/srcversion.h>
__SRCVERSION("$URL: http://svn.ott.qnx.com/product/branches/6.6.0/trunk/hardware/can/mx6x/driver.c $ $Rev: 809384 $")
#endif
